法1：DP动态规划法，利用三个指针a b c同时代表2 3 5的依次倍数，重点是找到状态转移方程，取最小的那个数最为本次dp[i]的值
不知道题目中的哈希表是干什么的，净误导我，导致想偏了，fuck，自己想的写法超时了，逐个数字加一的方法，超时太正常了
时间O(N)  空间O(N)
执行用时：4 ms, 在所有 C++ 提交中击败了92.26% 的用户
内存消耗：7.5 MB, 在所有 C++ 提交中击败了52.36% 的用户
class Solution {
public:
    int nthUglyNumber(int n) {
        vector<int> dp(n, 1);           // 初始n个1
        int a = 0, b = 0, c = 0;        // 初始三个指针都指向数组首位
        for(int i = 1; i < n; i++)
        {
            int n1 = dp[a] * 2, n2 = dp[b] * 3, n3 = dp[c] * 5;   // 三个临时数字，分别代表下一次2 3 5的倍数
            dp[i] = min(min(n1, n2), n3);                         // 取最小的值
            if(dp[i] == n1)    a++;                               // 若取到该值，将对应指针向前挪一位，有可能同时挪动两个指针，比如 2*3 = 3*2
            if(dp[i] == n2)    b++;
            if(dp[i] == n3)    c++;
        } 
        return dp[n-1];                                           // 最后返回dp[n-1]
    }
};
