法1：数学公式法，同剪绳子Ⅰ差不多，只不过受到测试用例限制，不能用pow函数直接求幂，需要循环取余的方式逐渐×3最后输出，刚开始都错傻了555
时间O(N)  空间O(1)
执行用时：0 ms, 在所有 C++ 提交中击败了100.00% 的用户
内存消耗：5.7 MB, 在所有 C++ 提交中击败了91.49% 的用户
class Solution {
public:
    int cuttingRope(int n) {
        if(n <= 3)    return n - 1;         // 特殊情况处理
        long res = 1;                       // 注意res需要设置成long类型，否则会发生int类型溢出
        while(n > 4)
        {
            res = 3 * res % 1000000007;     // 循环取余即可
            n -= 3;
        }
        res = n * res % 1000000007;
        return (int)res;
    }
};

法2：动态规划dp不知道还适用不
