法1：正常遍历法，啥技巧性操作都没用上，评价还贼高，也不知道为啥是困难题...
时间O(NK)  空间O(1)
执行用时：8 ms, 在所有 C++ 提交中击败了99.62% 的用户
内存消耗：15.3 MB, 在所有 C++ 提交中击败了86.16% 的用户
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> res;
        if(nums.empty())    return res;
        int max = nums[0];                                // max保存当前k长度中的最大值
        for(int i = 0; i < k; i++)                        // 第一轮遍历k个值，记录最大值max
        {
            if(nums[i] > max)    max = nums[i];
        }
        res.push_back(max);
        for(int i = k; i < nums.size(); i++)              // 第二轮继续遍历，依次向后移动一个元素，若该元素比max大，直接记录，若当前最大值即将移出，遍历新的k个元素找到最大值并保存
        {
            if(nums[i] >= max)
            {
                max = nums[i];
            }
            else if(nums[i - k] == max)
            {
                max = nums[i];
                for(int j = i - k + 1; j < i; j++)
                {
                    if(nums[j] > max)    max = nums[j];
                }
            }
            res.push_back(max);
        }
        return res;
    }
};
