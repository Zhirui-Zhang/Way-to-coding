法1：DFS+BFS，感觉太笨了，检查所有节点向下的所有路径，只是我想的其他巧解都写不出来
时间O(N^2)  空间O(N)
执行用时：28 ms, 在所有 C++ 提交中击败了39.98% 的用户
内存消耗：15.4 MB, 在所有 C++ 提交中击败了45.87% 的用户
class Solution {
public:
    int pathSum(TreeNode* root, int targetSum) {
        if(!root)    return 0;
        queue<TreeNode*> q;
        q.push(root);       // 先BFS，遍历所有节点，把所有节点送入DFS
        while(!q.empty()){
            TreeNode* tmp = q.front();
            q.pop();
            dfs(tmp, targetSum);
            if(tmp->left){
                q.push(tmp->left);
            }
            if(tmp->right){
                q.push(tmp->right);
            }
        }
        return res;
    }
private:
    int res;
    void dfs(TreeNode* root, int targetSum){    //常规BFS写法，后序遍历，注意剪枝
        if(!root){
            return;
        }
        targetSum -= root->val;
        if(targetSum == 0){
            res++;
        }
        dfs(root->left, targetSum);
        dfs(root->right, targetSum);
        targetSum += root->val;   
    }
};
