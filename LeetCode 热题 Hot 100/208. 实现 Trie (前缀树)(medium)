法1：哈希表，自己做的，就是字典树，每个哈希表存储首字符，后面挂一个vector<string>数组，每次find一边即可
时间O(NM)N为放入单词的个数，M为每个单词的长度，查找比较时会用到  空间O(N)
执行用时：120 ms, 在所有 C++ 提交中击败了7.54% 的用户
内存消耗：24.7 MB, 在所有 C++ 提交中击败了98.29% 的用户
class Trie {
private:
    unordered_map<char, vector<string>> un_map;
public:
    Trie() {

    }
    
    void insert(string word) {   
        un_map[word[0]].push_back(word);
    }
    
    bool search(string word) {
        char i = word[0];
        return un_map.find(i) != un_map.end() && find(un_map[i].begin(), un_map[i].end(), word) != un_map[i].end();
    }
    
    bool startsWith(string prefix) {
        char i = prefix[0];
        if(un_map.find(i) != un_map.end())
        {
            for(auto word : un_map[i])
            {
                int j = 1;
                for(; j < word.size() && j < prefix.size(); ++j)
                {
                    if(word[j] != prefix[j])    break;
                }
                if(j == prefix.size())    return true;
            }
        }
        return false;
    }
};

法2：字典树/前缀树，和我的解法不太一样，思考一样
时间O()  空间O()
