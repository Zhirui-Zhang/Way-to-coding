法1：快排法，练习一下模板，针对本题可以更快一点
时间O(NlogN)  空间O(logN)
执行用时：280 ms, 在所有 C++ 提交中击败了5.09% 的用户
内存消耗：10 MB, 在所有 C++ 提交中击败了12.31% 的用户
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        int n = nums.size();
        QuickSort(nums, 0, n-1);
        return nums[n-k];
    }
private:
    void QuickSort(vector<int>& nums, int left, int right)
    {
        if(left >= right)    return;
        int i = left, j = right;
        while(i < j)
        {
            while(i < j && nums[left] <= nums[j])    --j;
            while(i < j && nums[left] >= nums[i])    ++i;
            swap(nums[i], nums[j]);
        }
        swap(nums[i], nums[left]);
        QuickSort(nums, left, i-1);
        QuickSort(nums, i+1, right);
    }
};

改进版：增加哨兵k，只排前k个元素即可
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        int n = nums.size();
        QuickSort(nums, k, 0, n-1);
        return nums[n-k];
    }
private:
    void QuickSort(vector<int>& nums, int k, int left, int right)
    {
        if(left >= right)    return;
        int i = left, j = right;
        while(i < j)
        {
            while(i < j && nums[left] <= nums[j])    --j;
            while(i < j && nums[left] >= nums[i])    ++i;
            swap(nums[i], nums[j]);
        }
        swap(nums[i], nums[left]);
        if(i > k)    QuickSort(nums, k, left, i - 1);
        else if(i < k)    QuickSort(nums, k, i + 1, right);
        else return;
    }
};

法3：优先队列，小顶堆法，和剑指的那道题还有点小不同，注意一下写法
时间O(NlogK)  空间O(K)
执行用时：4 ms, 在所有 C++ 提交中击败了96.41% 的用户
内存消耗：9.8 MB, 在所有 C++ 提交中击败了51.95% 的用户
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        int n = nums.size();
        priority_queue<int, vector<int>, greater<int>> q;
        for(int i = 0; i < k; ++i)    q.push(nums[i]);
        for(int i = k; i < n; ++i)
        {
            if(nums[i] > q.top())
            {
                q.pop();
                q.push(nums[i]);
            }
        }
        return q.top();
    }
};
