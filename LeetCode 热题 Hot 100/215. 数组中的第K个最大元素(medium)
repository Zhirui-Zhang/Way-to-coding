法1：快排法，练习一下模板，针对本题可以更快一点
时间O(NlogN)  空间O(logN)
执行用时：280 ms, 在所有 C++ 提交中击败了5.09% 的用户
内存消耗：10 MB, 在所有 C++ 提交中击败了12.31% 的用户
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        int n = nums.size();
        QuickSort(nums, 0, n-1);
        return nums[n-k];
    }
private:
    void QuickSort(vector<int>& nums, int left, int right)
    {
        if(left >= right)    return;
        int i = left, j = right;
        while(i < j)
        {
            while(i < j && nums[left] <= nums[j])    --j;
            while(i < j && nums[left] >= nums[i])    ++i;
            swap(nums[i], nums[j]);
        }
        swap(nums[i], nums[left]);
        QuickSort(nums, left, i-1);
        QuickSort(nums, i+1, right);
    }
};

改进版：增加哨兵k，只排前k个元素即可
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        int n = nums.size();
        QuickSort(nums, k, 0, n-1);
        return nums[n-k];
    }
private:
    void QuickSort(vector<int>& nums, int k, int left, int right)
    {
        if(left >= right)    return;
        int i = left, j = right;
        while(i < j)
        {
            while(i < j && nums[left] <= nums[j])    --j;
            while(i < j && nums[left] >= nums[i])    ++i;
            swap(nums[i], nums[j]);
        }
        swap(nums[i], nums[left]);
        if(i > k)    QuickSort(arr, k, left, i - 1);
        else if(i < k)    QuickSort(arr, k, i + 1, right);
        else return;
    }
};
