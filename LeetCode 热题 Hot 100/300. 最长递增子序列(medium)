法1：DP，没想到复杂度可以这么高，我一直在想怎么达到O(N)，结果用二分法才能O(NlogN)，是我想太多，状态转移方程  dp[i]=max(dp[i], dp[j]+1)  j∈[0, i)
时间O(N^2)  空间O(N)
执行用时：268 ms, 在所有 C++ 提交中击败了39.51% 的用户
内存消耗：10.1 MB, 在所有 C++ 提交中击败了88.66% 的用户
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int res = 0, n = nums.size();
        vector<int> dp(n, 1);       // dp数组初始为每个长度为1，即只包含自己
        for(int i = 0; i < n; ++i)
        {
            for(int j = 0; j < i; ++j)    // 遍历i和j寻找完全递增数组的长度，并与自身比较更新
            {
                if(nums[j] < nums[i])    dp[i] = max(dp[i], dp[j]+1);
            }
            res = max(res, dp[i]);        // 更新当前最长长度
        }
        return res;
    }
};
